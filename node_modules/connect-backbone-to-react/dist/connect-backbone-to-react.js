'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hoistStatics = require('hoist-non-react-statics');

var _require = require('react'),
    Component = _require.Component,
    createElement = _require.createElement;

var PropTypes = require('prop-types');
var debounceFn = require('lodash.debounce');

function getDisplayName(name) {
  return 'connectBackboneToReact(' + name + ')';
}

function defaultMapModelsToProps(models) {
  return Object.keys(models).reduce(function (acc, modelKey) {
    var model = models[modelKey];
    acc[modelKey] = model.toJSON();
    return acc;
  }, {});
}

module.exports = function connectBackboneToReact(mapModelsToProps) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof mapModelsToProps !== 'function') {
    mapModelsToProps = defaultMapModelsToProps;
  }

  var _options$debounce = options.debounce,
      debounce = _options$debounce === undefined ? false : _options$debounce,
      _options$events = options.events,
      events = _options$events === undefined ? {} : _options$events,
      _options$modelTypes = options.modelTypes,
      modelTypes = _options$modelTypes === undefined ? {} : _options$modelTypes;


  function getEventNames(modelName) {
    var eventNames = events[modelName];

    // Allow turning off event handlers by setting events to false.
    if (eventNames === false) {
      return [];
    }

    if (!Array.isArray(eventNames)) {
      return ['all'];
    }

    return eventNames;
  }

  function validateModelTypes(modelsMap) {
    return Object.keys(modelTypes).forEach(function (modelKey) {
      var ModelConstructor = modelTypes[modelKey];
      var modelInstance = modelsMap[modelKey];

      var isInstanceOfModel = modelInstance instanceof ModelConstructor;
      if (!isInstanceOfModel) {
        throw new Error('"' + modelKey + '" model found on modelsMap does not match type required.');
      }
    });
  }

  return function createWrapper(WrappedComponent) {
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var ConnectBackboneToReact = function (_Component) {
      _inherits(ConnectBackboneToReact, _Component);

      function ConnectBackboneToReact(props, context) {
        _classCallCheck(this, ConnectBackboneToReact);

        var _this = _possibleConstructorReturn(this, (ConnectBackboneToReact.__proto__ || Object.getPrototypeOf(ConnectBackboneToReact)).call(this, props, context));

        _this.models = props.models || context.models;

        validateModelTypes(_this.models);

        _this.state = mapModelsToProps(_this.models);

        _this.createNewProps = _this.createNewProps.bind(_this);

        if (debounce) {
          var debounceWait = typeof debounce === 'number' ? debounce : 0;
          _this.createNewProps = debounceFn(_this.createNewProps, debounceWait);
        }

        _this.createEventListeners();
        return _this;
      }

      _createClass(ConnectBackboneToReact, [{
        key: 'createEventListeners',
        value: function createEventListeners() {
          var _this2 = this;

          Object.keys(this.models).forEach(function (mapKey) {
            var model = _this2.models[mapKey];

            getEventNames(mapKey).forEach(function (name) {
              model.on(name, _this2.createNewProps, _this2);
            });
          });
        }
      }, {
        key: 'createNewProps',
        value: function createNewProps() {
          // Bail out if our component has been unmounted.
          // The only case where this flag is encountered is when this component
          // is unmounted within an event handler but the 'all' event is still triggered.
          // It is covered in a test case.
          if (this.hasBeenUnmounted) {
            return;
          }

          this.setState(mapModelsToProps(this.models));
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          var _this3 = this;

          if (debounce) {
            this.createNewProps.cancel();
          }

          Object.keys(this.models).forEach(function (mapKey) {
            var model = _this3.models[mapKey];

            getEventNames(mapKey).forEach(function (name) {
              model.off(name, _this3.createNewProps, _this3);
            });
          });

          this.hasBeenUnmounted = true;
        }
      }, {
        key: 'render',
        value: function render() {
          var wrappedProps = Object.assign({}, this.state, this.props);

          // Don't pass through models prop.
          wrappedProps.models = undefined;

          return createElement(WrappedComponent, wrappedProps);
        }
      }]);

      return ConnectBackboneToReact;
    }(Component);

    var propTypes = {
      models: PropTypes.object
    };

    ConnectBackboneToReact.WrappedComponent = WrappedComponent;
    ConnectBackboneToReact.displayName = displayName;
    ConnectBackboneToReact.propTypes = propTypes;
    ConnectBackboneToReact.contextTypes = propTypes;

    return hoistStatics(ConnectBackboneToReact, WrappedComponent);
  };
};